Dia2Code v. 0.9.0

SUMMARY

This program generates code for many languages from an UML Dia Diagram.


DESCRIPTION

This program is a small utility that makes code from a Dia diagram. Supported
languages are: ActionScript3, Ada, C, C++(99,11), C#, IDL, Java, PHP(4,5),
Python, Ruby, shapefiles, and SQL create statement files.

Its intended purpose is to ease the programmer's work by generating
the structure of the classes in an Object Oriented language
(like C++, Java and C#) from a graphical representation of them
(a Dia Diagram).


STATUS

Dia2Code generates ActionScript, Ada, C, C++, C#, IDL, Java, PHP, Python, Ruby,
and shape files.
It can also generate a file with SQL's CREATE TABLE statements and .bat files
for creating shapes. Templates and packages are supported.

The generation of #include and import directives is automatically done
considering the types used in each class but they may be added by dependencies.
Classes are automatically searched in the types of:
attributes, method's return types, method's parameters, parents, dependencies
and associations.

Dia2Code handles Associations, Dependencies, Realizations, Implements and
Generalizations.

Feel free to have a try and send me your comments.


LICENSE

This program is distributed under the GNU GPLv3.
Read the COPYING file for details.


REQUIREMENTS

Works under Linux (i386 and x64) and Win32/Win64.
Feedback about other platforms is welcome.

- Dia (I work with 0.97.2 but older versions *may* be OK).
- libxml2 headers and development libraries (I use 2.9 but it *may* be
  OK if you use any version greater than 2.0).
- A C++ compiler which supports C++11 standard (>=gcc 4.6).
- automake and autoconf (actually, optional)


INSTALLATION

Usually:

        $ ./configure --with-corba

        $ make

        $ make check

        # make install

Read the INSTALL file for details.

If that doesn't work for you, try (from the src's dia2code directory):

        $ g++ -std=c++11 -I/usr/include/libxml2 *.cpp -O2 -o dia2codetest -lxml2 -I..

        $ strip dia2code

To cross-compiling from Linux (build=x86_64-pc-linux-gnu):
        - To Win32, with package cross-i686-pc-mingw32/gcc:
        # ./configure --disable-static --enable-shared --build=x86_64-pc-linux-gnu --host=i686-pc-mingw32

        - To Win64, with package cross-x86_64-w64-mingw32/gcc:
        # ./configure --disable-static --enable-shared --build=x86_64-pc-linux-gnu --host=x86_64-w64-mingw32

        - To Linux32:
        # ./configure --disable-static --enable-shared -m32

        - To Linux64:
        # ./configure --disable-static --enable-shared -m64


OPERATION

    $ dia2code <parameters>

Where <parameters> can be any combination of:

-h --help            Print this help and exit.
-d <dir>             Output generated files to <dir>, default is "."
--buildtree          Convert package names to a directory tree.
                     Imply -1. Off by default.
-l <license>         License file to prepend to generated files.
-nc                  Do not overwrite files that already exist.
-cl <classlist>      Generate code only for the classes specified in
                     the comma-separated <classlist>.
                     E.g: Base,Derived.
-v                   Invert the class list selection.  When used
                     without -cl prevents any file from being created.
--version            Show version x.y.z.
--tab <number>       Set number of spaces for one indentation.
                     Default: 4. Maximum: 8.
-ext <extension>     Use <extension> as the file extension.
                     Here are the defaults:
                     ada:"ads", c:"h", cpp:"hpp", idl:"idl",
                     java:"java", php:"php", python:"py",
                     csharp:"cs".
                     Not applicable to shp, sql.
-bext <extension>    Use <extension> as the body (implementation) file
                     extension. Only applies to ada and c.
                     Here are the defaults:
                     ada:"adb", c:"c".
-nl                  Create new line on new brace. Off by default.
-1                   One header contains only one header. If two classes
                     have the same name, they will be overwritten without
                     --buildtree.
                     Off by default but java.
-t <target>          Selects the output language. <target> can be one of:
                     ada,as3,c,cpp,cpp11,csharp,idl,java,php,php5,python,
                     ruby,shp,sql.
<diagramfile>        The Dia file that holds the diagram to be read.

The only mandatory parameters are the diagram file name and the target.

Note: Parameters can be specified in any order.


EXAMPLES

    $ dia2code -t java test.dia

    Will generate the *.java files for the classes in the test.dia diagram
    and put them in the current directory.

    $ dia2code -t cpp -nc -d ~/C++ hw.dia

    Will generate the *.cpp and *.h files for the classes in the test.dia
    diagram and put them in the directory ~/C++. It won't overwrite any
    existant file.

    $ dia2code -t java -cl Base,Derived test.dia

    Will create the Java files only for classes "Base" and "Derived".

    $ dia2code -t cpp -cl B*,*Foo test.dia

    Will create the *.hpp files for classes that begin with "B" or
    end with "Foo".
    NOTE: You can only specify one asterisk and either at the beginning or end
    of the pattern.
    NOTE2: You may have to quote the asterisks when typing on the shell
    (e.g. "\*" instead of "*")

    $ dia2code -t cpp -cl Foo -v foobar.dia

    Will create C++ code for all classes but "Foo".

    $ dia2code -t cpp -v test.dia

    Will not create any files. Don't know if it may be useful, but it surely
    is syntactically correct.


NOTES ON UML

What you should put into your diagram

These are mandatory:

- A non-empty class or package name.
- For each attribute, the name and type.
- For each method, the name.
- For each method's parameter, the name and type.

These are optional:

- The stereotype of the class.
- The default value of attributes.
- The default value of parameters.
- The return type of a method. If no type is declared, dia2code
  will output no type at all for it.


OUTPUT

This section shows some examples of UML diagram converted to code without use
of stereotype.
Lines starting with double stars are comments to explain the process of the
generation of the code.

Common:
If -1 and --buildtree are not specified, the name of each file will be the
class name (if not in a package) and the name of the top package either.
If -1 or --buildtree is specified, the filename will be the class name.


C++ generator:
** The license if specified in command line (-l option).
/*
File bit-by-bit.
 */

** Header guard
#ifndef README__HPP
#define README__HPP

** Dependancies
#include "dependancies.hpp"

** Templates
template <type template>

** Namespace if class are in package.
namespace package {
    ** Class with inheritance if necessary.
    class Class : public ParentClass {
        ** Visibility of the attribut / operation. Public, private, protected
        ** are supported. Implementation is not, default will be public.
        ** Attributes will be print first, then operations.
        // Attributes
        ** Default value are ignored. for attribute.
        public :
            ** Comments are in doxygen format.
            /// Comment for the first
            /// attribute.
            type1 nom1;
        private :
            /// Exemple of static attribut.
            static type2 nom2;
        protected :
            type3 nom3;
        // Operations
        public :
            /**
             * \class AbstractOperation
             * \brief Multiple line
             *        comment
             */
            ** An abstact operation must not be define so " = 0".
            virtual AbstractOperation () = 0;
            ** A virtual operation must be define in the source code.
            virtual VirtualOperation ();
            NonAbstractOperation ();
            /**
             * \brief comment
             * \param in (in)
             * \param inOut (in/out) comment2
             * \param undef (???)
             * \param out (out)
             */
            virtual type test (type1 in, type2 inOut, type3 undef = 0, type4 out) = 0;
            static test2 ();
            test3 () const;
    };
}

** End of header guard
#endif


C++11 generator:
** The license if specified in command line (-l option).
/*
File bit-by-bit.
 */

** Header guard
#ifndef README__HPP
#define README__HPP

** Dependancies
#include "dependancies.hpp"

** Templates
template <type template>

** Namespace if class are in package.
namespace package {
    ** Class with inheritance if necessary.
    class Class : public ParentClass {
        ** Visibility of the attribut / operation. Public, private, protected
        ** are supported. Implementation is not, default will be public.
        ** Attributes will be print first, then operations.
        // Attributes
        ** Default value are ignored. for attribute.
        public :
            ** Comments are in doxygen format.
            /// Comment for the first
            /// attribute.
            type1 nom1;
        private :
            /// Exemple of static attribut.
            static type2 nom2;
        protected :
            type3 nom3;
        // Operations
        public :
            /**
             * \class AbstractOperation
             * \brief Multiple line
             *        comment
             */
            ** An abstact operation must not be define so " = 0".
            virtual AbstractOperation () = 0;
            ** A virtual operation must be define in the source code.
            virtual VirtualOperation ();
            NonAbstractOperation ();
            /**
             * \brief comment
             * \param in (in)
             * \param inOut (in/out) comment2
             * \param undef (???)
             * \param out (out)
             */
            virtual type test (type1 in, type2 inOut, type3 undef = 0, type4 out) = 0;
            static test2 ();
            constexpr test3 ();
    };
}

** End of header guard
#endif


Java generator:
** The license if specified in command line (-l option).
/*
File bit-by-bit.
 */

** No header guard

** Dependancies
import Dependancies;

** Templates not supported.

** If class are in package.
package Pack;

** Class with inheritance if necessary.
public class Class extends ParentClass {
    ** Attributes will be print first, then operations.
    // Attributes
    ** Comments are in doxygen format.
    /**
     * comment.
     */
    public type1 nom1 = val1;
    private static type2 nom2;
    protected type3 nom3 = val3;
    // Operations
    public abstract AbstractOperation ();
    ** In Java all operation are virtual.
    public VirtualOperation ();
    public NonAbstractOperation ();
    /**
     * comment
     * @param in (in)
     * @param inOut (in/out) comment2
     * @param undef (???)
     * @param out (out)
     * @return type
     */
    public abstract type test (type1 in, type2 inOut, type3 undef = 0, type4 out);
    public static test2 ();
    ** There is no const function is Java.
    public test3 ();
}


STEREOTYPES

Only one stereotype can be apply on each class, attribute, operation and
inheritance.


- Inheritance or Realization of an interface:

By default, all inheritances are public. Some language, like C++, allow a
different visibility like protected or private.
Possible value: public, private, protected, implementation.

C++ and C++11 generator:
** The stereotype of Generalization (or Realizes) of three classes are public,
** protected and private.
** Implementation visibility is not applicable to C++ generator.
class InheritanceClasseChildren : public InheritanceClasseImplement, protected InheritanceClasseProtected, private InheritancePack1::InheritanceClassePrivate {
};

C++ and C++11 generator:
** In Java, Generalization are public only.
class InheritanceClasseChildren extends InheritanceClasseImplement extends InheritanceClasseProtected extends InheritancePack1.InheritanceClassePrivate {
};



- Classes:

CORBAValue:
  To enable Corba to a class, the stereotype must be CORBAValue.

GetSet
  Generate all get/set functions of all attributes. Their visibility will be
  public.

  A "T getA ();" method, with return type conformant to the type of the
  attribute. If the type of the attribute is boolean (boolean, Boolean or bool)
  then the name will be: "T isA ()".

  A "void setA (T value);" method, with a parameter, "value", with type
  conformant to the type of the attribute.

C++ generator:
** The stereotype of the class is GetSet.
// Stereotype : GetSet
class GetSet {
    // Attributes
    private :
        char * nom;
        bool boole;
    // Operations
    public :
        void setNom (char * value);
        char * getNom () const;
        void setBoole (bool value);
        bool isBoole () const;
}

C++11 generator:
** The stereotype of the class is GetSet.
// Stereotype : GetSet
class GetSet {
    // Attributes
    private :
        char * nom;
        bool boole;
    // Operations
    public :
        void setNom (char * value);
        constexpr char * getNom ();
        void setBoole (bool value);
        constexpr bool isBoole ();
}


Java generator:
** The stereotype of the class is GetSet.
// Stereotype : GetSet
public class GetSet {
    // Attributes
    private char * nom;
    private bool boole;
    // Operations
    public void setNom (char * value) {
    }
    public char * getNom () {
    }
    public void setBoole (bool value) {
    }
    public bool isBoole () {
    }
}


const, constant, Const, Constant or CORBAConstant:

TODO


enum, enumeration, Enum, Enumeration or CORBAEnum:

Generate an enum class. Only attributes will be used. Template or function are
ignored.


C++ generator:
/// Comment of the enum
enum enumeration {
    /// Comment ENUM_1
    ENUM_1 = 0,
    /// Comment ENUM_2
    ENUM_2,
    /// Comment ENUM_3
    ENUM_3
};


C++11 generator:
/// Comment of the enum
enum class enumeration {
    /// Comment ENUM_1
    ENUM_1 = 0,
    /// Comment ENUM_2
    ENUM_2,
    /// Comment ENUM_3
    ENUM_3
};


Java generator:
/**
 * Comment of the enum
 */
public enum enumeration {
    /// Comment ENUM_1
    ENUM_1 = 0,
    /// Comment ENUM_2
    ENUM_2,
    ENUM_3
};


struct, structure, Struct, Structure, or CORBAStruct:

A structure is almost the same as a class.


C++ and C++11 generator:
** In C++, all attributes and operations are public.
/// Comment about the structure.
struct structure {
    // Attributes
    /// com1
    type1 nom1;
    /// com2-1
    /// com2-2
    type2 nom2;
    type3 nom3;
    // Operations
    void operation (type1 attr1);
};


Java generator:
** In Java, structure is not defined. The equivalent is a class.
/**
 * Comment about the structure.
 */
public class structure {
    // Attributes
    /**
     * com1
     */
    public type1 nom1;
    /**
     * com2-1
     * com2-2
     */
    private type2 nom2;
    protected type3 nom3;
    // Operations
    public void operation (type1 attr1) {
    }
};


typedef, Typedef or CORBATypedef:

A typedef defines a type as a derivated of another one.
The name of the new type is the name of the classe.
The name of the derivated type is the name of the first attribute.
All other information is ignored.
Not applicable in Java.


C++ and C++11 generator:
typedef TypeDerivated NewType;


Java generator:
Not applicable.


- Operation:

delete:
In C++11, a deleted function must be defined in header.
Not applicable in Java.

C++ generator:
** In C++, delete do not exists. So the commun way to delete a function (like
** copy constructor) is to make this function private and to not defining it in
** source.
class operations {
    private :
        test5 ();
}


C++11 generator:
class operations {
    public :
        test5 () = delete;
}


Java generator:
class operations {
    public test5 () {
    }
}


- Attributes:

Some stereotypes are supported that all begin with "CORBA". These are:
CORBAConstant, CORBAEnum, CORBAException, CORBANative, CORBATypedef,
CORBAStruct, CORBAUnion, CORBAValue.
When generating IDL, the corresponding IDL syntax is generated for the UML
class. When generating other languages, a rough mapping from the IDL to the
other language is generated.

The following conventions are followed by the code generation for CORBA
stereotypes:

Constant   First attribute's type contains the const type; first attribute's
           value contains the const's value. Everything else unused.
Enum       Attribute names contain the enum literals, everything else unused.
Exception  TODO.
Native     TODO.
Typedef    First attribute's type contains the original type;
           first attribute's value optionally contains the dimensions
           in case of an array. Everything else unused.
Struct     Attribute names and types contain the struct members.
           Everything else unused.
Union      First attribute's type contains the switch type. Only
           enum types are supported as the switch type.
           Following attributes contain the union cases as follows:
           Attribute value contains the switch value for the case
           (only exactly one value possible per case); attribute
           name and type contains the union member name and type
           for that case.
           Everything else unused.
Value      Use much like a normal class. Staticness not supported.


MISCELLANEOUS

Visibility

Dia2Code does not handle the "implementation" visibility for methods.
So when you have a class that implements a method that was declared
abstract in a base class, you have to give it the same visibility of the
parent class' method. The visibility of the method is not printed if it is
"implementation"; this may be a source of bugs.


Method's return type

If you leave the "type" entry in the method declaration empty, then no
type will be declared for it. This is useful with constructors, when the
return type is implicit (both in C++ and Java). If the return type is
void, you should explicitly declare it in the UML diagram.


Packages

The UML standard states that there are two ways of representing packages:
a large box with all the elements inside (Large Package in Dia) or a small box
(Small Package in Dia) to which the package's elements connect with a symbol
that Dia does not include: a line with a crossed out circle in the end of the
container. You can put a normal line with a "Coordiate origin" arrow at one
end, of course, and will be aesthetically correct, but of no use to Dia2Code.

Dia2code, currently, checks only for intersections of packages (Large or
Small) with other objects like classes and other packages, so it will
be mostly useful with diagrams that use Large Packages instead of Small
ones.


INFORMATION FOR DEVELOPERS

How it works:

1. Parse the diagram file with xmlParseFile().
2. Parse the tree generated in 1 for UML classes to build an
   umlclasslist (type defined here).
3. Parse the tree again for UML Generalizations, Realizations,
   Implements, Dependencies, Associations and packages to add information
   to the class list.
4. Generate the structure of the classes (write it into files)
   from the class list.

Steps 1-3 are done in parse_diagram ().
Step 4 is done in GenerateCode* ().
Both functions are called from main ().


Code Generators:

**IMPORTANT**: When a modification is done in a generator, BE SURE to do the
same with all generators if necessary.

A code generator (class derived from GenerateCode) is a class that takes 
reference to a DiaGram class.

The DiaGram class contains:
  - std::list <umlClassNode> uml; // a list of all class nodes.

The GenerateCode class contains:
  - DiaGram &   dia;           // a reference to a DiaGram class.
  - std::string license;       // file that contains the license.
  - std::string outdir;        // folder where to write the headers.
                               // empty for current folder.
  - std::string file_ext;      // extension of header.
  - std::string body_file_ext; // extension of body file (if usefull).

  - uint8_t     indent : 4; // number of space of each indent.
    uint32_t    getIndent () const;
    void        setIndent (uint8_t spaces);

  - bool        overwrite : 1; // allow overwriting existing file.
    bool        getOverwrite () const;
    void        setOverwrite (bool over);

  - bool        buildtree : 1; // create one folder for each package.
    bool        getBuildTree () const;
    void        setBuildTree (bool build);

  - bool        bOpenBraceOnNewline : 1; // open brace on new line.
    bool        getOpenBraceOnNewline () const;
    void        setOpenBraceOnNewline (bool newline);

  - bool        oneClassOneHeader : 1; // Only one class par header.
    bool        getOneClass () const;
    void        setOneClass (bool val);


New generator:

The new generator is a class that inherits from GenerateCode. All virtual
functions must be overridden. Developers can get an idea on how to write a
new generator by having a good look inside GenerateCodeCpp.cpp.

  - writeLicense ();
Write the license at the top of each header. The characters that start and end
multiple line comments must be added before and after the file.
The license is specified by the attribute license.

  - writeStartHeader (std::string & name);
Write the mechanism that avoids multiple inclusion (applies to C/C++).
  - writeEndHeader ();
Finish the mechanism that avoids multiple inclusion.

  - writeInclude (std::basic_string <char> name);
  - writeInclude (const char * name);
Write the instruction that includes a file (header).

  - writeFunctionComment (const umlOperation & ope);
Write the comment for a function and its parameters. Use well-known format.
C++ uses doxygen format.

  - writeFunction (const umlOperation & ope, int * curr_visibility);
Write the header of a function. The current visibility is used to avoid writing
it every time.

  - writeComment (const std::string & text);
  - writeComment (const char * text);
Write a single comment, not in the well-known format.

  - writeClassComment (const umlClassNode & node);
Write the comment for a class by using the well-known format.

  - writeClass (const umlClassNode & node);
Write the beginning of a class (name, inheritance and visibility).
  - writeClassEnd ();
End the class.

  - writeAttribute (const umlAttribute & attr, int * curr_visibility);
Write an attribute inside of a class.

  - writeNameSpaceStart (const umlClassNode * name);
Start a package.
  - writeNameSpaceEnd (const umlClassNode * node);
End a package.

  - writeConst (const umlClassNode & node);
Write a class which is a const type (stereotype "const", "constant" or
"CORBAConstant").

  - writeEnum (const umlClassNode & node);
Write a class which is an enum type (stereotype "enum", "enumeration" or
"CORBAEnum").

  - writeStruct (const umlClassNode & node);
Write a class which is an structure type (stereotype "struct", "structure" or
"CORBAStruct").

  - writeTypedef (const umlClassNode & node);
Write a class which is a typedef type (stereotype "typedef" or "CORBATypedef").

  - writeAssociation (const umlassoc & asso);
Write an association.

  - writeTemplates (
               const std::list <std::pair <std::string, std::string> > & tmps);
Write a template.

Add a new generator to the main program:
The following files needs to be updated:
 - src/main.cpp:
     - add a new include at the top of the file with the header of the new
       generator.
     - inside the variable const char *help, add the abreviation of the
       language.
     - inside the variable const char *bighelp, change -ext, -bext and -t
       options.
     - and finally add it inside the main loop, in "case 1".
 - src/Makefile.am:
     - add the source in dia2code_SOURCES,
     - add the header in EXTRA_DIST.
 - README:
     - add examples for classic classes and for the differents stereotypes.
And of course, don't forget to run "git add GenerateCodeXXX.?pp".


KNOWN BUGS

- Packages of classes are searched using the position and size instead of
  <dia:childnode parent="O0"/>


AUTHOR

Javier O'Hara <joh314@users.sourceforge.net>


MAINTAINER

Richard Torkar <richard.torkar@htu.se>

Contributors: (in alphabetical order, by last name)
- Cyrille Chepelov <chepelov@calixo.net> Pyhton code generation, Debian package
  management, Hurd conformance.
- Harald Fielker <hfielker@softsolutions.de> PHP code generation.
- Oliver Kellogg <okellogg@users.sourceforge.net>, CORBA stereotype and package
  support
- Vincent Le Garrec (bansan) <vincent@le-garrec.fr> Conversion to C++.
- Ruben Lopez <ryu@gpul.org>, C code generation.
- Steffen Macke <sdteffen@yahoo.com> batch shapefile generation, win32
  installer.
- Chris McGee <sirnewton_01@yahoo.ca> Dependencies, Associations,
  C++ Templates, SQL, IDL code generation.
- Takashi Okamoto <toraneko@kun.ne.jp> License inclusion mechanism.
- Thomas Preymesser <tp@odn.de> Ada code generation.
- Dmitry V. Sabanin <sdmitry@lrn.ru> Ruby code generation.
- Jérôme Slangen <jeromes@mail.be> Wildcard class list mechanism.
- Takaaki Tateishi <> Dynamic Shared Objects for dynamic code generator
  modules. Feature removed.
- Martin Vidner <mvidner@users.sourceforge.net> Porting to libxml2.
- Thomas Hansen <thomas.hansen@adramatch.com> C# code generation.


THANKS

Thanks to Collin Starkweather and Slush Gore for the extra help.
Also, thanks to all the people that have contacted me with suggestions and bug
reports.
