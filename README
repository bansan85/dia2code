Dia2Code v. 0.9.0

SUMMARY

This program generates code for many languages from an UML Dia Diagram.


DESCRIPTION

This program is a small utility that makes code from a Dia diagram. Supported
languages are: ActionScript3, Ada, C, C++(99,11), C#, IDL, Java, PHP(4,5),
Python, Ruby, shapefiles, and SQL create statement files.

Its intended purpose is to ease the programmer's work by generating
the structure of the classes in an Object Oriented language
(like C++, Java and C#) from a graphical representation of them
(a Dia Diagram).


STATUS

Dia2Code generates ActionScript, Ada, C, C++, C#, IDL, Java, PHP, Python, Ruby,
and shape files.
It can also generate a file with SQL's CREATE TABLE statements and .bat files
for creating shapes. Templates and packages are supported.

The generation of #include and import directives is automatically done
considering the types used in each class but they may be added by dependencies.
Classes are automatically searched in the types of:
attributes, method's return types, method's parameters, parents, dependencies
and associations.

Dia2Code handles Associations, Dependencies, Realizations, Implements and
Generalizations.

Feel free to have a try and send me your comments.


LICENSE

This program is distributed under the GNU GPLv3.
Read the COPYING file for details.


REQUIREMENTS

Works under Linux (i386 and x64) and Win32/Win64.
Feedback about other platforms is welcome.

- Dia (I work with 0.97.2 but older versions *may* be OK).
- libxml2 headers and development libraries (I use 2.9 but it *may* be
  OK if you use any version greater than 2.0).
- A C++ compiler which supports C++11 standard (>=gcc 4.6).
- automake and autoconf (actually, optional)


INSTALLATION

Usually:

        $ ./configure --with-corba

        $ make

        $ make check

        # make install

Read the INSTALL file for details.

If that doesn't work for you, try (from the src's dia2code directory):

        $ g++ -std=c++11 -I/usr/include/libxml2 *.cpp -O2 -o dia2codetest -lxml2 -I..

        $ strip dia2code

To cross-compiling from Linux (build=x86_64-pc-linux-gnu):
        - To Win32, with package cross-i686-pc-mingw32/gcc:
        # ./configure --disable-static --enable-shared --build=x86_64-pc-linux-gnu --host=i686-pc-mingw32

        - To Win64, with package cross-x86_64-w64-mingw32/gcc:
        # ./configure --disable-static --enable-shared --build=x86_64-pc-linux-gnu --host=x86_64-w64-mingw32

        - To Linux32:
        # ./configure --disable-static --enable-shared -m32

        - To Linux64:
        # ./configure --disable-static --enable-shared -m64


OPERATION

    $ dia2code <parameters>

Where <parameters> can be any combination of:

-h --help            Print this help and exit.\n\
-d <dir>             Output generated files to <dir>, default is \".\" \n\
--buildtree          Convert package names to a directory tree.\n\
                     Imply -1. Off by default.\n\
-l <license>         License file to prepend to generated files.\n\
-nc                  Do not overwrite files that already exist.\n\
-cl <classlist>      Generate code only for the classes specified in\n\
                     the comma-separated <classlist>. \n\
                     E.g: Base,Derived.\n\
-v                   Invert the class list selection.  When used \n\
                     without -cl prevents any file from being created.\n\
--version            Show version x.y.z.\n\
--tab <number>       Set number of spaces for one indentation.\n\
                     Default: 4. Maximum: 8.\n\
-ext <extension>     Use <extension> as the file extension.\n\
                     Here are the defaults:\n\
                     ada:\"ads\", c:\"h\", cpp:\"hpp\", idl:\"idl\",\n\
                     java:\"java\", php:\"php\", python:\"py\",\n\
                     csharp:\"cs\".\n\
                     Not applicable to shp, sql.\n\
-bext <extension>    Use <extension> as the body (implementation) file\n\
                     extension. Only applies to ada and c.\n\
                     Here are the defaults:\n\
                     ada:\"adb\", c:\"c\".\n\
-nl                  Create new line on new brace. Off by default.\n\
-1                   One header contains only one header. If two classes\n\
                     have the same name, they will be overwritten without\n\
                     --buildtree.\n\
                     Off by default but java.\n\
-t <target>          Selects the output language. <target> can be one of:\n\
                     ada,as3,c,cpp,cpp11,csharp,idl,java,php,php5,python,\n\
                     ruby,shp,sql.\n\
<diagramfile>        The Dia file that holds the diagram to be read.\n\

The only mandatory parameters are the diagram file name and the target.

Note: Parameters can be specified in any order.


EXAMPLES

    $ dia2code -t java test.dia

    Will generate the *.java files for the classes in the test.dia diagram
    and put them in the current directory.

    $ dia2code -t cpp -nc -d ~/C++ hw.dia

    Will generate the *.cpp and *.h files for the classes in the test.dia
    diagram and put them in the directory ~/C++. It won't overwrite any
    existant file.

    $ dia2code -t java -cl Base,Derived test.dia

    Will create the Java files only for classes "Base" and "Derived".

    $ dia2code -t cpp -cl B*,*Foo test.dia

    Will create the *.hpp files for classes that begin with "B" or
    end with "Foo".
    NOTE: You can only specify one asterisk and either at the beginning or end
    of the pattern.
    NOTE2: You may have to quote the asterisks when typing on the shell
    (e.g. "\*" instead of "*")

    $ dia2code -t cpp -cl Foo -v foobar.dia

    Will create C++ code for all classes but "Foo".

    $ dia2code -t cpp -v test.dia

    Will not create any files. Don't know if it may be useful, but it surely
    is syntactically correct.


HOW IT WORKS

1. Parse the diagram file with xmlParseFile().
2. Parse the tree generated in 1 for UML classes to build an
   umlclasslist (type defined here).
3. Parse the tree again for UML Generalizations, Realizations,
   Implements, Dependencies, Associations and packages to add information
   to the class list.
4. Generate the structure of the classes (write it into files)
   from the class list.

Steps 1-3 are done in parse_diagram ().
Step 4 is done in GenerateCode* ().
Both functions are called from main ().


NOTES ON UML

What you should put into your diagram

These are mandatory:

- A non-empty class or package name.
- For each attribute, the name and type.
- For each method, the name.
- For each method's parameter, the name and type.

These are optional:

- The stereotype of the class.
- The default value of attributes.
- The default value of parameters.
- The return type of a method. If no type is declared, dia2code
  will output no type at all for it.


STEREOTYPES

Only one stereotype can be apply on each class.

- Classes:

CORBAValue To enable Corba to a class, the stereotype must be CORBAValue.
GetSet     Generate all get/set functions of all attributes.
           - A "T getA ();" method, with return type conformant to the type of
             the attribute. If the type of the attribute is "boolean" then the
             name will be: "boolean isA ()".
           - A "void setA (T value);" method, with a parameter, "value", with
             type conformant to the type of the attribute.

- Attributes:

Some stereotypes are supported that all begin with "CORBA". These are:
CORBAConstant, CORBAEnum, CORBAException, CORBANative, CORBATypedef,
CORBAStruct, CORBAUnion, CORBAValue.
When generating IDL, the corresponding IDL syntax is generated for the UML
class. When generating other languages, a rough mapping from the IDL to the
other language is generated.

The following conventions are followed by the code generation for CORBA
stereotypes:

Constant   First attribute's type contains the const type; first attribute's
           value contains the const's value. Everything else unused.
Enum       Attribute names contain the enum literals, everything else unused.
Exception  TODO.
Native     TODO.
Typedef    First attribute's type contains the original type;
           first attribute's value optionally contains the dimensions
           in case of an array. Everything else unused.
Struct     Attribute names and types contain the struct members.
           Everything else unused.
Union      First attribute's type contains the switch type. Only
           enum types are supported as the switch type.
           Following attributes contain the union cases as follows:
           Attribute value contains the switch value for the case
           (only exactly one value possible per case); attribute
           name and type contains the union member name and type
           for that case.
           Everything else unused.
Value      Use much like a normal class. Staticness not supported.


Visibility

Dia2Code does not handle the "implementation" visibility for methods.
So when you have a class that implements a method that was declared
abstract in a base class, you have to give it the same visibility of the
parent class' method. The visibility of the method is not printed if it is
"implementation"; this may be a source of bugs.


Method's return type

If you leave the "type" entry in the method declaration empty, then no
type will be declared for it. This is useful with constructors, when the
return type is implicit (both in C++ and Java). If the return type is
void, you should explicitly declare it in the UML diagram.


Packages

The UML standard states that there are two ways of representing packages:
a large box with all the elements inside (Large Package in Dia) or a small box
(Small Package in Dia) to which the package's elements connect with a symbol
that Dia does not include: a line with a crossed out circle in the end of the
container. You can put a normal line with a "Coordiate origin" arrow at one
end, of course, and will be aesthetically correct, but of no use to Dia2Code.

Dia2code, currently, checks only for intersections of packages (Large or
Small) with other objects like classes and other packages, so it will
be mostly useful with diagrams that use Large Packages instead of Small
ones.


INFORMATION FOR DEVELOPERS

Code Generators:

A code generator (class derived from GenerateCode) is a class that takes 
reference to a DiaGram class.

The DiaGram class contains:
  - std::list <umlClassNode> uml; // a list of all class nodes.

The GenerateCode class contains:
  - DiaGram &   dia;           // a reference to a DiaGram class.
  - std::string license;       // file that contains the license.
  - std::string outdir;        // folder where to write the headers.
                               // empty for current folder.
  - std::string file_ext;      // extension of header.
  - std::string body_file_ext; // extension of body file (if usefull).

  - uint8_t     indent : 4; // number of space of each indent.
    uint32_t    getIndent () const;
    void        setIndent (uint8_t spaces);

  - bool        overwrite : 1; // allow overwriting existing file.
    bool        getOverwrite () const;
    void        setOverwrite (bool over);

  - bool        buildtree : 1; // create one folder for each package.
    bool        getBuildTree () const;
    void        setBuildTree (bool build);

  - bool        bOpenBraceOnNewline : 1; // open brace on new line.
    bool        getOpenBraceOnNewline () const;
    void        setOpenBraceOnNewline (bool newline);

  - bool        oneClassOneHeader : 1; // Only one class par header.
    bool        getOneClass () const;
    void        setOneClass (bool val);

New generator:

The new generator is a class that inherits from GenerateCode. All virtual
functions must be overridden. Developers can get an idea on how to write a
new generator by having a good look inside GenerateCodeCpp.cpp.

  - writeLicense ();
Write the license at the top of each header. The characters that start and end
multiple line comments must be added before and after the file.
The license is specified by the attribute license.

  - writeStartHeader (std::string & name);
Write the mechanism that avoids multiple inclusion (applies to C/C++).
  - writeEndHeader ();
Finish the mechanism that avoids multiple inclusion.

  - writeInclude (std::basic_string <char> name);
  - writeInclude (const char * name);
Write the instruction that includes a file (header).

  - writeFunctionComment (const umlOperation & ope);
Write the comment for a function and its parameters. Use well-known format.
C++ uses doxygen format.

  - writeFunction (const umlOperation & ope, int * curr_visibility);
Write the header of a function. The current visibility is used to avoid writing
it every time.

  - writeComment (const std::string & text);
  - writeComment (const char * text);
Write a single comment, not in the well-known format.

  - writeClassComment (const umlClassNode & node);
Write the comment for a class by using the well-known format.

  - writeClass (const umlClassNode & node);
Write the beginning of a class (name, inherence and visibility).
  - writeClassEnd ();
End the class.

  - writeAttribute (const umlAttribute & attr, int * curr_visibility);
Write an attribute inside of a class.

  - writeNameSpaceStart (const umlClassNode * name);
Start a package.
  - writeNameSpaceEnd (const umlClassNode * node);
End a package.

  - writeConst (const umlClassNode & node);
Write a class which is a const type (stereotype "const", "constant" or
"CORBAConstant").

  - writeEnum (const umlClassNode & node);
Write a class which is an enum type (stereotype "enum", "enumeration" or
"CORBAEnum").

  - writeStruct (const umlClassNode & node);
Write a class which is an structure type (stereotype "struct", "structure" or
"CORBAStruct").

  - writeTypedef (const umlClassNode & node);
Write a class which is a typedef type (stereotype "typedef" or "CORBATypedef").

  - writeAssociation (const umlassoc & asso);
Write an association.

  - writeTemplates (
               const std::list <std::pair <std::string, std::string> > & tmps);
Write a template.

Add a new generator to the main program:
The following files needs to be updated:
 - src/main.cpp:
     - add a new include at the top of the file with the header of the new
       generator.
     - inside the variable const char *help, add the abreviation of the
       language.
     - inside the variable const char *bighelp, change -ext, -bext and -t
       options.
     - and finally add it inside the main loop, in "case 1".
 - src/Makefile.am
     - add the source in dia2code_SOURCES,
     - add the header in EXTRA_DIST.
And of course, don't forget to run "git add GenerateCodeXXX.?pp".


KNOWN BUGS

- Does not follow the DTD of a Dia Diagram, rather parses as it sees fit.
- Packages of classes are searched using the position and size instead of
  <dia:childnode parent="O0"/>


AUTHOR

Javier O'Hara <joh314@users.sourceforge.net>


MAINTAINER

Richard Torkar <richard.torkar@htu.se>

Contributors: (in alphabetical order, by last name)
- Cyrille Chepelov <chepelov@calixo.net> Pyhton code generation, Debian package
  management, Hurd conformance.
- Harald Fielker <hfielker@softsolutions.de> PHP code generation.
- Oliver Kellogg <okellogg@users.sourceforge.net>, CORBA stereotype and package
  support
- Vincent Le Garrec (bansan) <vincent@le-garrec.fr> Conversion to C++.
- Ruben Lopez <ryu@gpul.org>, C code generation.
- Steffen Macke <sdteffen@yahoo.com> batch shapefile generation, win32
  installer.
- Chris McGee <sirnewton_01@yahoo.ca> Dependencies, Associations,
  C++ Templates, SQL, IDL code generation.
- Takashi Okamoto <toraneko@kun.ne.jp> License inclusion mechanism.
- Thomas Preymesser <tp@odn.de> Ada code generation.
- Dmitry V. Sabanin <sdmitry@lrn.ru> Ruby code generation.
- Jérôme Slangen <jeromes@mail.be> Wildcard class list mechanism.
- Takaaki Tateishi <> Dynamic Shared Objects for dynamic code generator
  modules. Feature removed.
- Martin Vidner <mvidner@users.sourceforge.net> Porting to libxml2.
- Thomas Hansen <thomas.hansen@adramatch.com> C# code generation.


THANKS

Thanks to Collin Starkweather and Slush Gore for the extra help.
Also, thanks to all the people that have contacted me with suggestions and bug
reports.
